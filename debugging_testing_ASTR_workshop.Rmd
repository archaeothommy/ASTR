---
output: html_document
editor_options: 
  chunk_output_type: console
---

# Debugging & testing in R

- Some practical advice how to (1) debug R code and how to (2) use testing in R package development.

## Debugging

Finding and fixing issues in code.

### Demonstration

- See faulty function `testfun` in test.R
- Build the package
- Run with `ASTR::testfun(3)`to demonstrate how the function fails

With the debugger:

- Set debug flags, rebuild the package
- Run again and use the debugger

Interactive:

- Set input variables in global environment `x <- 3`
- Run the function with the REPL

## Testing

Running code to validate its behavior.

### Goals

- Validation:
    Making sure that the code performs exactly as expected,
    also for edge cases.
- Robustness:
    Ensuring that future modifications by the code do not interfere
    with the expected behavior.
- Documentation:
    Showing how the code is intended to be used.
(- Planning:
    Describing expectations for code that still needs to be written;
    test-driven development.)

### Types of tests (as relevant for R package development)

- Unit tests:
    Low level tests of individual pieces of code (functions).
- Integration/Functional tests:
    Tests to check workflows and the interaction of functions.

- Golden/Snapshot tests:
    Validate the output of a function against a pre-defined,
    supposedly correct, "golden" output.
- Property based tests:
    Run tests not on specific-predefined input, but on dynamically
    generated input that fulfills certain properties.

### Setup

- The testthat R package: https://testthat.r-lib.org
- A good introduction: https://r-pkgs.org/testing-basics.html

- Tests live in `tests/testthat` and require some technical overhead/settings.
- Tests for a certain context (e.g. pca analysis) live in files named `test_....R`.
- All tests can be run with `devtools::test()` (or Ctrl+Shift+T in RStudio).
- All tests are also run on GitHub when you push to an open PR branch.

### Examples

```{r}
library(testthat)
```

#### Unit tests

Low level tests of individual pieces of code (functions).

Function of interest:

```{r}
testfun <- function(x) {
  y <- x + 5
  z <- y + 6
  return(z)
}
```

Basic test setup by defining expectations:

```{r}
# working
test_that("behaves as expected for specific input", {
  expect_equal(testfun(3), 14)
})
# failing
test_that("behaves as expected for specific input", {
  expect_equal(testfun(3), 13)
})
# multiple expectations
test_that("behaves as expected for specific input", {
  expect_equal(testfun(3), 14)
  expect_equal(testfun(4), 15)
})
# expectations implemented in testthat
test_that("behaves as expected for specific input", {
  expect_true(testfun(3) == 14)
  expect_gt(testfun(3), 13)
  expect_type(testfun(3), "double")
  expect_error(testfun("my_string"))
  expect_silent(testfun(3))
})
```

Example: https://github.com/ropensci/c14bazAAR

#### Golden/Snapshot tests

Validate the output of a function against a pre-defined, supposedly correct, "golden" output.

Example: https://github.com/nevrome/currycarbon

- :warning: Excessive use can get unwieldy.
- testthat can automatically generate and update output snapshots in a human-readable form.

##### Demonstration

- Copy the following test to `test_archchem_basic.R`

```{r}
test_that("as_archchem transform input data.frames correctly", {
  expect_snapshot({
    test_data <- tibble::tibble(
      "Al2O3_%" = c(1,2,3),
      "Fe_Âµg/g" = c(4,5,6)
    )
    as_archchem(test_data)
  })
})
```

- Run tests with `devtools::test()`: Snapshot gets automatically created
- Inspect .md at `tests/testthat/_snaps`
- Run tests again to see the tests pass
- Modify test and run again to see a snapshot test fail
- Accept change with `testthat::snapshot_accept('archchem_basic')`
- Run tests again to register the difference.

##### Plot tests

Test if a plot can be reproduced.

- :warning: The exact rendering of a plot depends on many factors. Plot tests tend to be extremely brittle.
- vdiffr is a testthat extension for monitoring the appearance of R plots. It generates reproducible SVG files and registers them as testthat snapshots.

Demonstration as above:

```{r}
library(ggplot2) # add to tests/testthat/setup.R

p <- ggplot() +
  geom_point(
    data = iris,
    aes(x = Sepal.Length, y = Sepal.Width, colour = Species)
  )

test_that("as_archchem transform input data.frames correctly", {
  expect_snapshot({
    vdiffr::expect_doppelganger("Iris data test plot", p)
  })
})
```

#### Property based tests

Run tests not on specific-predefined input, but on dynamically generated input that fulfills certain properties.

Motivation:

```{r}
# increment the first element of any numerical vector by 1
# and return a numerical vector
testfun2 <- function(x) {
  x[1] <- x[1] + 1
  return(x)
}

# working
test_that("behaves as expected for specific input", {
  expect_equal(testfun2(c(1,2,3)), c(2,2,3))
})
test_that("behaves as expected for specific input", {
  expect_vector(testfun2(c(1,2,3)))
})
# but
test_that("behaves as expected for specific input", {
  expect_vector(testfun2(c()))
})
```

- The quickcheck R package (named after its Haskell ancestor) allows to test more generally for properties of functions, by trying lots of inputs.

```{r}
library(quickcheck)
test_that("map won't fail with any vector as input", {
  for_all(
    a = any_vector(),
    property = function(a) purrr::map(a, identity) %>% expect_silent()
  )
})
```


